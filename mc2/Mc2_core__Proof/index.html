<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mc2_core__Proof (mc2.Mc2_core__Proof)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">mc2</a> &#x00BB; Mc2_core__Proof</nav><h1>Module <code>Mc2_core__Proof</code></h1><p>Resolution proofs</p><p>This modules defines functions to create and manipulate resolution proofs.</p><nav class="toc"><ul><li><a href="#type-declarations">Type declarations</a></li><li><a href="#proof-building-functions">Proof building functions</a></li><li><a href="#proof-nodes">Proof Nodes</a></li><li><a href="#proof-manipulation">Proof Manipulation</a></li><li><a href="#misc">Misc</a></li><li><a href="#unsafe">Unsafe</a></li></ul></nav></header><section><header><h4 id="type-declarations"><a href="#type-declarations" class="anchor"></a>Type declarations</h4></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>Lazy type for proof trees. Proofs are persistent objects, and can be extended to proof nodes using functions defined later.</p></dd></dl><dl><dt class="spec type" id="type-node"><a href="#type-node" class="anchor"></a><code><span class="keyword">and</span> node</code><code> = </code><code>{</code><table class="record"><tr id="type-node.conclusion" class="anchored"><td class="def field"><a href="#type-node.conclusion" class="anchor"></a><code>conclusion : <a href="../Mc2_core__/Solver_types/index.html#type-clause">Mc2_core__.Solver_types.clause</a>;</code></td><td class="doc"><p>The conclusion of the proof</p></td></tr><tr id="type-node.step" class="anchored"><td class="def field"><a href="#type-node.step" class="anchor"></a><code>step : <a href="index.html#type-step">step</a>;</code></td><td class="doc"><p>The reasoning step used to prove the conclusion</p></td></tr></table><code>}</code></dt><dd><p>A proof can be expanded into a proof node, which show the first step of the proof.</p></dd></dl><dl><dt class="spec type" id="type-step"><a href="#type-step" class="anchor"></a><code><span class="keyword">and</span> step</code><code> = </code><table class="variant"><tr id="type-step.Hypothesis" class="anchored"><td class="def constructor"><a href="#type-step.Hypothesis" class="anchor"></a><code>| </code><code><span class="constructor">Hypothesis</span></code></td><td class="doc"><p>The conclusion is a user-provided hypothesis</p></td></tr><tr id="type-step.Assumption" class="anchored"><td class="def constructor"><a href="#type-step.Assumption" class="anchor"></a><code>| </code><code><span class="constructor">Assumption</span></code></td><td class="doc"><p>The conclusion has been locally assumed by the user</p></td></tr><tr id="type-step.Lemma" class="anchored"><td class="def constructor"><a href="#type-step.Lemma" class="anchor"></a><code>| </code><code><span class="constructor">Lemma</span> <span class="keyword">of</span> <a href="../Mc2_core__/Solver_types/index.html#type-lemma">Mc2_core__.Solver_types.lemma</a></code></td><td class="doc"><p>The conclusion is a tautology provided by the theory, with associated proof</p></td></tr><tr id="type-step.Simplify" class="anchored"><td class="def constructor"><a href="#type-step.Simplify" class="anchor"></a><code>| </code><code><span class="constructor">Simplify</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id="type-step.init" class="anchored"><td class="def field"><a href="#type-step.init" class="anchor"></a><code>init : <a href="index.html#type-t">t</a>;</code></td></tr><tr id="type-step.duplicates" class="anchored"><td class="def field"><a href="#type-step.duplicates" class="anchor"></a><code>duplicates : <span><a href="../Mc2_core__/Solver_types/index.html#type-atom">Mc2_core__.Solver_types.atom</a> list</span>;</code></td></tr><tr id="type-step.absurd" class="anchored"><td class="def field"><a href="#type-step.absurd" class="anchor"></a><code>absurd : <span><a href="../Mc2_core__/Solver_types/index.html#type-atom">Mc2_core__.Solver_types.atom</a> list</span>;</code></td></tr></table><code>}</code></td><td class="doc"><p>The conclusion is obtained by eliminating multiple occurrences of atoms in the conclusion of the provided proof, and removing some absurd atoms.</p></td></tr><tr id="type-step.Hyper_res" class="anchored"><td class="def constructor"><a href="#type-step.Hyper_res" class="anchor"></a><code>| </code><code><span class="constructor">Hyper_res</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id="type-step.init" class="anchored"><td class="def field"><a href="#type-step.init" class="anchor"></a><code>init : <a href="index.html#type-t">t</a>;</code></td></tr><tr id="type-step.steps" class="anchored"><td class="def field"><a href="#type-step.steps" class="anchor"></a><code>steps : <span><a href="../Mc2_core__/Solver_types/index.html#type-premise_step">Mc2_core__.Solver_types.premise_step</a> list</span>;</code></td></tr></table><code>}</code></td><td class="doc"><p>The conclusion can be deduced by performing a series of resolution steps between <code>init</code> and, successively, each clause in the list on the corresponding pivot atom.</p></td></tr></table></dt><dd><p>A proof can be expanded into a proof node, which show the first step of the proof.</p><p>The type of reasoning steps allowed in a proof.</p></dd></dl><dl><dt class="spec value" id="val-conclusion"><a href="#val-conclusion" class="anchor"></a><code><span class="keyword">val</span> conclusion : <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="../Mc2_core__/Solver_types/index.html#type-clause">Mc2_core__.Solver_types.clause</a></code></dt><dt class="spec value" id="val-step"><a href="#val-step" class="anchor"></a><code><span class="keyword">val</span> step : <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-step">step</a></code></dt></dl></section><section><header><h4 id="proof-building-functions"><a href="#proof-building-functions" class="anchor"></a>Proof building functions</h4></header><dl><dt class="spec value" id="val-prove"><a href="#val-prove" class="anchor"></a><code><span class="keyword">val</span> prove : <a href="../Mc2_core__/Solver_types/index.html#type-clause">Mc2_core__.Solver_types.clause</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Given a clause, return a proof of that clause.</p><dl><dt>raises Util.Error</dt><dd><p>if it does not succeed.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-prove_unsat"><a href="#val-prove_unsat" class="anchor"></a><code><span class="keyword">val</span> prove_unsat : <a href="../Mc2_core__/Solver_types/index.html#type-clause">Mc2_core__.Solver_types.clause</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Given a conflict clause <code>c</code>, returns a proof of the empty clause.</p><dl><dt>raises Util.Error</dt><dd><p>if it does not succeed</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-prove_atom"><a href="#val-prove_atom" class="anchor"></a><code><span class="keyword">val</span> prove_atom : <a href="../Mc2_core__/Solver_types/index.html#type-atom">Mc2_core__.Solver_types.atom</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> option</span></code></dt><dd><p>Given an atom <code>a</code>, returns a proof of the clause <code>[a]</code> if <code>a</code> is true at level 0</p></dd></dl></section><section><header><h4 id="proof-nodes"><a href="#proof-nodes" class="anchor"></a>Proof Nodes</h4></header><dl><dt class="spec value" id="val-is_leaf"><a href="#val-is_leaf" class="anchor"></a><code><span class="keyword">val</span> is_leaf : <a href="index.html#type-step">step</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns whether the proof node is a leaf, i.e. an hypothesis, an assumption, or a lemma. <code>true</code> if and only if <code>parents</code> returns the empty list.</p></dd></dl><dl><dt class="spec value" id="val-expl"><a href="#val-expl" class="anchor"></a><code><span class="keyword">val</span> expl : <a href="index.html#type-step">step</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Returns a short string description for the proof step; for instance <code>&quot;hypothesis&quot;</code> for a <code>Hypothesis</code> (it currently returns the variant name in lowercase).</p></dd></dl><dl><dt class="spec value" id="val-parents"><a href="#val-parents" class="anchor"></a><code><span class="keyword">val</span> parents : <a href="index.html#type-step">step</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span></code></dt><dd><p>Returns the parents of a proof node.</p></dd></dl></section><section><header><h4 id="proof-manipulation"><a href="#proof-manipulation" class="anchor"></a>Proof Manipulation</h4></header><dl><dt class="spec value" id="val-expand"><a href="#val-expand" class="anchor"></a><code><span class="keyword">val</span> expand : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-node">node</a></code></dt><dd><p>Return the proof step at the root of a given proof.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold f acc p</code>, fold <code>f</code> over the proof <code>p</code> and all its node. It is guaranteed that <code>f</code> is executed exactly once on each proof node in the tree, and that the execution of <code>f</code> on a proof node happens after the execution on the parents of the nodes.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>(<a href="index.html#type-node">node</a> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unsat_core"><a href="#val-unsat_core" class="anchor"></a><code><span class="keyword">val</span> unsat_core : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../Mc2_core__/Solver_types/index.html#type-clause">Mc2_core__.Solver_types.clause</a> list</span></code></dt><dd><p>Returns the unsat_core of the given proof, i.e the lists of conclusions of all leafs of the proof. More efficient than using the <code>fold</code> function since it has access to the internal representation of proofs</p></dd></dl><dl><dt class="spec value" id="val-debug_step"><a href="#val-debug_step" class="anchor"></a><code><span class="keyword">val</span> debug_step : <span><a href="index.html#type-step">step</a> CCFormat.printer</span></code></dt></dl></section><section><header><h4 id="misc"><a href="#misc" class="anchor"></a>Misc</h4></header><dl><dt class="spec value" id="val-check_step"><a href="#val-check_step" class="anchor"></a><code><span class="keyword">val</span> check_step : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Check only this proof step</p></dd></dl><dl><dt class="spec value" id="val-check"><a href="#val-check" class="anchor"></a><code><span class="keyword">val</span> check : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Check the contents of a proof. Mainly for internal use</p></dd></dl></section><section><header><h4 id="unsafe"><a href="#unsafe" class="anchor"></a>Unsafe</h4></header><dl><dt class="spec module" id="module-H"><a href="#module-H" class="anchor"></a><code><span class="keyword">module</span> H : CCHashtbl.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-H">H</a>.key = <a href="../Mc2_core__/Solver_types/index.html#type-clause">Mc2_core__.Solver_types.clause</a></code></dt><dd><p>Hashtable over clauses. Uses the details of the internal representation to achieve the best performances, however hashtables from this module become invalid when solving is restarted, so they should only be live during inspection of a single proof.</p></dd></dl></section></div></body></html>