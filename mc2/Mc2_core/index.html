<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mc2_core (mc2.Mc2_core)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">mc2</a> &#x00BB; Mc2_core</nav><h1>Module <code>Mc2_core</code></h1><h2 id="core-library"><a href="#core-library" class="anchor"></a>Core Library</h2></header><aside><p>This library contains the core structures and algorithms of mc2. It defines terms, types, values, the main solver, plugins, etc.</p></aside><div class="spec module" id="module-Atom"><a href="#module-Atom" class="anchor"></a><code><span class="keyword">module</span> <a href="Atom/index.html">Atom</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-Term"><a href="#module-Term" class="anchor"></a><code><span class="keyword">module</span> <a href="Term/index.html">Term</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><dl><dt class="spec module" id="module-Type"><a href="#module-Type" class="anchor"></a><code><span class="keyword">module</span> <a href="Type/index.html">Type</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><dl><dt class="spec module" id="module-Value"><a href="#module-Value" class="anchor"></a><code><span class="keyword">module</span> <a href="Value/index.html">Value</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><dl><dt class="spec module" id="module-Actions"><a href="#module-Actions" class="anchor"></a><code><span class="keyword">module</span> <a href="Actions/index.html">Actions</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><dl><dt class="spec module" id="module-Builtins"><a href="#module-Builtins" class="anchor"></a><code><span class="keyword">module</span> <a href="Builtins/index.html">Builtins</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><dl><dt class="spec module" id="module-Clause"><a href="#module-Clause" class="anchor"></a><code><span class="keyword">module</span> <a href="Clause/index.html">Clause</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><dl><dt class="spec module" id="module-Proof"><a href="#module-Proof" class="anchor"></a><code><span class="keyword">module</span> <a href="Proof/index.html">Proof</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Resolution proofs</p></dd></dl><dl><dt class="spec module" id="module-Solver"><a href="#module-Solver" class="anchor"></a><code><span class="keyword">module</span> <a href="Solver/index.html">Solver</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Main Interface for the Solver</p></dd></dl><dl><dt class="spec module" id="module-Service"><a href="#module-Service" class="anchor"></a><code><span class="keyword">module</span> <a href="Service/index.html">Service</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><dl><dt class="spec module" id="module-Plugin"><a href="#module-Plugin" class="anchor"></a><code><span class="keyword">module</span> <a href="Plugin/index.html">Plugin</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><dl><dt class="spec module" id="module-Tseitin"><a href="#module-Tseitin" class="anchor"></a><code><span class="keyword">module</span> <a href="Tseitin/index.html">Tseitin</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Tseitin CNF conversion</p></dd></dl><dl><dt class="spec module" id="module-ID"><a href="#module-ID" class="anchor"></a><code><span class="keyword">module</span> <a href="ID/index.html">ID</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><dl><dt class="spec module" id="module-Lemma"><a href="#module-Lemma" class="anchor"></a><code><span class="keyword">module</span> <a href="Lemma/index.html">Lemma</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><div class="spec module" id="module-Statement"><a href="#module-Statement" class="anchor"></a><code><span class="keyword">module</span> <a href="Statement/index.html">Statement</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Bound_var"><a href="#module-Bound_var" class="anchor"></a><code><span class="keyword">module</span> <a href="Bound_var/index.html">Bound_var</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Error"><a href="#module-Error" class="anchor"></a><code><span class="keyword">module</span> <a href="Error/index.html">Error</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Fmt"><a href="#module-Fmt" class="anchor"></a><code><span class="keyword">module</span> Fmt = CCFormat</code></div><div class="spec module" id="module-Int_map"><a href="#module-Int_map" class="anchor"></a><code><span class="keyword">module</span> Int_map = <a href="Util/index.html#module-Int_map">Util.Int_map</a></code></div><dl><dt class="spec type" id="type-level"><a href="#type-level" class="anchor"></a><code><span class="keyword">type</span> level</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-level">Mc2_core__.Solver_types.level</a></code></dt><dd><p>Backtracking level</p></dd></dl><dl><dt class="spec type" id="type-ty_view"><a href="#type-ty_view" class="anchor"></a><code><span class="keyword">type</span> ty_view</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-ty_view">Mc2_core__.Solver_types.ty_view</a></code><code> = </code><code>..</code></dt><dd><p>Extensible view on types</p></dd></dl><dl><dt class="spec type" id="type-term_view"><a href="#type-term_view" class="anchor"></a><code><span class="keyword">type</span> term_view</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-term_view">Mc2_core__.Solver_types.term_view</a></code><code> = </code><code>..</code></dt><dd><p>Extensible view on terms (generalized variables). Each plugin might declare its own terms.</p></dd></dl><dl><dt class="spec type" id="type-value_view"><a href="#type-value_view" class="anchor"></a><code><span class="keyword">type</span> value_view</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-value_view">Mc2_core__.Solver_types.value_view</a></code><code> = </code><code>..</code></dt><dd><p>Extensible view on values.</p></dd></dl><dl><dt class="spec type" id="type-lemma_view"><a href="#type-lemma_view" class="anchor"></a><code><span class="keyword">type</span> lemma_view</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-lemma_view">Mc2_core__.Solver_types.lemma_view</a></code><code> = </code><code>..</code></dt><dd><p>Extensible proof object</p></dd></dl><dl><dt class="spec type" id="type-decide_state"><a href="#type-decide_state" class="anchor"></a><code><span class="keyword">type</span> decide_state</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-decide_state">Mc2_core__.Solver_types.decide_state</a></code><code> = </code><code>..</code></dt><dd><p>State carried by a given term, depending on its type, and used for decisions and propagations related to the term. Typically it contains a set of constraints on the values this term can have (lower/upper bounds, etc.)</p></dd></dl><dl><dt class="spec type" id="type-tc_ty"><a href="#type-tc_ty" class="anchor"></a><code><span class="keyword">type</span> tc_ty</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-tc_ty">Mc2_core__.Solver_types.tc_ty</a></code></dt><dt class="spec type" id="type-tc_term"><a href="#type-tc_term" class="anchor"></a><code><span class="keyword">type</span> tc_term</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-tc_term">Mc2_core__.Solver_types.tc_term</a></code></dt><dd><p>type class for terms, packing all operations on terms</p></dd></dl><dl><dt class="spec type" id="type-tc_value"><a href="#type-tc_value" class="anchor"></a><code><span class="keyword">type</span> tc_value</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-tc_value">Mc2_core__.Solver_types.tc_value</a></code></dt><dt class="spec type" id="type-tc_lemma"><a href="#type-tc_lemma" class="anchor"></a><code><span class="keyword">type</span> tc_lemma</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-tc_lemma">Mc2_core__.Solver_types.tc_lemma</a></code></dt><dt class="spec type" id="type-term"><a href="#type-term" class="anchor"></a><code><span class="keyword">type</span> term</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-term">Mc2_core__.Solver_types.term</a></code></dt><dd><p>Main term representation. It is worth noting that terms are also (generalized) <i>variables</i> and behave mostly the same as boolean variables for the main solver, meaning that they need to be assigned a value in the model.</p></dd></dl><dl><dt class="spec type" id="type-atom"><a href="#type-atom" class="anchor"></a><code><span class="keyword">type</span> atom</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-atom">Mc2_core__.Solver_types.atom</a></code></dt><dd><p>Atoms and variables wrap theory formulas. They exist in the form of triplet: a variable and two atoms. For a formula <code>f</code> in normal form, the variable v points to the positive atom <code>a</code> which wraps <code>f</code>, while <code>a.neg</code> wraps the theory negation of <code>f</code>.</p></dd></dl><dl><dt class="spec type" id="type-clause"><a href="#type-clause" class="anchor"></a><code><span class="keyword">type</span> clause</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-clause">Mc2_core__.Solver_types.clause</a></code></dt><dd><p>The type of clauses. Each clause generated should be true, i.e. enforced by the current problem (for more information, see the cpremise field).</p></dd></dl><dl><dt class="spec type" id="type-lemma"><a href="#type-lemma" class="anchor"></a><code><span class="keyword">type</span> lemma</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-lemma">Mc2_core__.Solver_types.lemma</a></code><code> = </code><table class="variant"><tr id="type-lemma.Lemma_bool_tauto" class="anchored"><td class="def constructor"><a href="#type-lemma.Lemma_bool_tauto" class="anchor"></a><code>| </code><code><span class="constructor">Lemma_bool_tauto</span></code></td><td class="doc"><p>tautology <code>a âˆ¨ Â¬a</code></p></td></tr><tr id="type-lemma.Lemma_custom" class="anchored"><td class="def constructor"><a href="#type-lemma.Lemma_custom" class="anchor"></a><code>| </code><code><span class="constructor">Lemma_custom</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id="type-lemma.view" class="anchored"><td class="def field"><a href="#type-lemma.view" class="anchor"></a><code>view : <a href="index.html#type-lemma_view">lemma_view</a>;</code></td><td class="doc"><p>The lemma content</p></td></tr><tr id="type-lemma.tc" class="anchored"><td class="def field"><a href="#type-lemma.tc" class="anchor"></a><code>tc : <a href="index.html#type-tc_lemma">tc_lemma</a>;</code></td><td class="doc"><p>Methods on the lemma</p></td></tr></table><code>}</code></td><td class="doc"><p>A lemma belonging to some plugin. Must be a tautology of the theory.</p></td></tr></table></dt><dt class="spec type" id="type-actions"><a href="#type-actions" class="anchor"></a><code><span class="keyword">type</span> actions</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-actions">Mc2_core__.Solver_types.actions</a></code></dt><dd><p>Actions available to terms/plugins when doing propagation/model building, including adding clauses, registering actions to do upon backtracking, etc.</p></dd></dl><dl><dt class="spec type" id="type-ty"><a href="#type-ty" class="anchor"></a><code><span class="keyword">type</span> ty</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-ty">Mc2_core__.Solver_types.ty</a></code><code> = </code><table class="variant"><tr id="type-ty.Bool" class="anchored"><td class="def constructor"><a href="#type-ty.Bool" class="anchor"></a><code>| </code><code><span class="constructor">Bool</span></code></td><td class="doc"><p>Builtin type of booleans</p></td></tr><tr id="type-ty.Ty" class="anchored"><td class="def constructor"><a href="#type-ty.Ty" class="anchor"></a><code>| </code><code><span class="constructor">Ty</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id="type-ty.id" class="anchored"><td class="def field"><a href="#type-ty.id" class="anchor"></a><code><span class="keyword">mutable</span> id : int;</code></td></tr><tr id="type-ty.view" class="anchored"><td class="def field"><a href="#type-ty.view" class="anchor"></a><code>view : <a href="index.html#type-ty_view">ty_view</a>;</code></td></tr><tr id="type-ty.tc" class="anchored"><td class="def field"><a href="#type-ty.tc" class="anchor"></a><code>tc : <a href="index.html#type-tc_ty">tc_ty</a>;</code></td></tr></table><code>}</code></td><td class="doc"><p>An atomic type, with some attached data</p></td></tr></table></dt><dd><p>Types</p></dd></dl><dl><dt class="spec type" id="type-value"><a href="#type-value" class="anchor"></a><code><span class="keyword">type</span> value</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-value">Mc2_core__.Solver_types.value</a></code><code> = </code><table class="variant"><tr id="type-value.V_true" class="anchored"><td class="def constructor"><a href="#type-value.V_true" class="anchor"></a><code>| </code><code><span class="constructor">V_true</span></code></td></tr><tr id="type-value.V_false" class="anchored"><td class="def constructor"><a href="#type-value.V_false" class="anchor"></a><code>| </code><code><span class="constructor">V_false</span></code></td></tr><tr id="type-value.V_value" class="anchored"><td class="def constructor"><a href="#type-value.V_value" class="anchor"></a><code>| </code><code><span class="constructor">V_value</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id="type-value.view" class="anchored"><td class="def field"><a href="#type-value.view" class="anchor"></a><code>view : <a href="index.html#type-value_view">value_view</a>;</code></td></tr><tr id="type-value.tc" class="anchored"><td class="def field"><a href="#type-value.tc" class="anchor"></a><code>tc : <a href="index.html#type-tc_value">tc_value</a>;</code></td></tr></table><code>}</code></td><td class="doc"><p>A semantic value, part of the model's domain. For arithmetic, it would be a number; for arrays, a finite map + default value; etc. Note that terms map to values in the model but that values are not necessarily normal &quot;terms&quot; (i.e. generalized variables in the MCSat sense).</p></td></tr></table></dt><dd><p>A value, either boolean or semantic</p></dd></dl><dl><dt class="spec type" id="type-var"><a href="#type-var" class="anchor"></a><code><span class="keyword">type</span> var</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-var">Mc2_core__.Solver_types.var</a></code></dt><dd><p>The &quot;generalized variable&quot; part of a term, containing the current assignment, watched literals/terms, etc.</p></dd></dl><dl><dt class="spec type" id="type-eval_res"><a href="#type-eval_res" class="anchor"></a><code><span class="keyword">type</span> eval_res</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-eval_res">Mc2_core__.Solver_types.eval_res</a></code><code> = </code><table class="variant"><tr id="type-eval_res.Eval_unknown" class="anchored"><td class="def constructor"><a href="#type-eval_res.Eval_unknown" class="anchor"></a><code>| </code><code><span class="constructor">Eval_unknown</span></code></td></tr><tr id="type-eval_res.Eval_into" class="anchored"><td class="def constructor"><a href="#type-eval_res.Eval_into" class="anchor"></a><code>| </code><code><span class="constructor">Eval_into</span> <span class="keyword">of</span> <a href="index.html#type-value">value</a> * <span><a href="index.html#type-term">term</a> list</span></code></td></tr></table></dt><dd><p>The type of evaluation results for a given formula. For instance, let's suppose we want to evaluate the formula <code>x * y = 0</code>, the following result are correct:</p><ul><li><code>Unknown</code> if neither <code>x</code> nor <code>y</code> are assigned to a value</li><li><code>Valued (true, [x])</code> if <code>x</code> is assigned to <code>0</code></li><li><code>Valued (true, [y])</code> if <code>y</code> is assigned to <code>0</code></li><li><code>Valued (false, [x; y])</code> if <code>x</code> and <code>y</code> are assigned to 1 (or any non-zero number)</li></ul></dd></dl><dl><dt class="spec type" id="type-assignment_view"><a href="#type-assignment_view" class="anchor"></a><code><span class="keyword">type</span> assignment_view</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-assignment_view">Mc2_core__.Solver_types.assignment_view</a></code><code> = </code><table class="variant"><tr id="type-assignment_view.A_bool" class="anchored"><td class="def constructor"><a href="#type-assignment_view.A_bool" class="anchor"></a><code>| </code><code><span class="constructor">A_bool</span> <span class="keyword">of</span> <a href="index.html#type-term">term</a> * bool</code></td></tr><tr id="type-assignment_view.A_semantic" class="anchored"><td class="def constructor"><a href="#type-assignment_view.A_semantic" class="anchor"></a><code>| </code><code><span class="constructor">A_semantic</span> <span class="keyword">of</span> <a href="index.html#type-term">term</a> * <a href="index.html#type-value">value</a></code></td></tr></table></dt><dt class="spec type" id="type-watch_res"><a href="#type-watch_res" class="anchor"></a><code><span class="keyword">type</span> watch_res</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-watch_res">Mc2_core__.Solver_types.watch_res</a></code><code> = </code><table class="variant"><tr id="type-watch_res.Watch_keep" class="anchored"><td class="def constructor"><a href="#type-watch_res.Watch_keep" class="anchor"></a><code>| </code><code><span class="constructor">Watch_keep</span></code></td></tr><tr id="type-watch_res.Watch_remove" class="anchored"><td class="def constructor"><a href="#type-watch_res.Watch_remove" class="anchor"></a><code>| </code><code><span class="constructor">Watch_remove</span></code></td></tr></table></dt><dt class="spec type" id="type-premise_step"><a href="#type-premise_step" class="anchor"></a><code><span class="keyword">type</span> premise_step</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-premise_step">Mc2_core__.Solver_types.premise_step</a></code><code> = </code><table class="variant"><tr id="type-premise_step.Step_resolve" class="anchored"><td class="def constructor"><a href="#type-premise_step.Step_resolve" class="anchor"></a><code>| </code><code><span class="constructor">Step_resolve</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id="type-premise_step.c" class="anchored"><td class="def field"><a href="#type-premise_step.c" class="anchor"></a><code>c : <a href="index.html#type-clause">clause</a>;</code></td></tr><tr id="type-premise_step.pivot" class="anchored"><td class="def field"><a href="#type-premise_step.pivot" class="anchor"></a><code>pivot : <a href="index.html#type-term">term</a>;</code></td></tr></table><code>}</code></td></tr></table></dt><dt class="spec type" id="type-check_res"><a href="#type-check_res" class="anchor"></a><code><span class="keyword">type</span> check_res</code><code> = <a href="../Mc2_core__/Solver_types/index.html#type-check_res">Mc2_core__.Solver_types.check_res</a></code><code> = </code><table class="variant"><tr id="type-check_res.Sat" class="anchored"><td class="def constructor"><a href="#type-check_res.Sat" class="anchor"></a><code>| </code><code><span class="constructor">Sat</span></code></td><td class="doc"><p>The current set of assumptions is satisfiable.</p></td></tr><tr id="type-check_res.Unsat" class="anchored"><td class="def constructor"><a href="#type-check_res.Unsat" class="anchor"></a><code>| </code><code><span class="constructor">Unsat</span> <span class="keyword">of</span> <span><a href="index.html#type-atom">atom</a> list</span> * <a href="index.html#type-lemma">lemma</a></code></td><td class="doc"><p>The current set of assumptions is *NOT* satisfiable, and here is a theory tautology (with its proof), for which every literal is false under the current assumptions.</p></td></tr></table></dt><dd><p>Result of checking satisfiability of a problem</p></dd></dl><dl><dt class="spec type" id="type-statement"><a href="#type-statement" class="anchor"></a><code><span class="keyword">type</span> statement</code><code> = <a href="Statement/index.html#type-t">Statement.t</a></code></dt></dl></div></body></html>