<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Proof (mc2.core.Mc2_core__.Proof)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../index.html">mc2.core</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Mc2_core__.Proof</span></h1></header><p>Resolution proofs</p><p>This modules defines functions to create and manipulate resolution proofs.</p><h4>Type declarations</h4><div class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>t</code><code></code><code></code></div><div class="doc"><p>Lazy type for proof trees. Proofs are persistent objects, and can be
extended to proof nodes using functions defined later.</p></div></div><div class="spec type" id="type-node"><a href="#type-node" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>node</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-node.conclusion" class="anchored"><td class="def field"><a href="#type-node.conclusion" class="anchor"></a><code>conclusion : <a href="../Solver_types/index.html#type-clause">Mc2_core__.Solver_types.clause</a>;</code></td><td class="doc"><p>(** The conclusion of the proof *)</p></td></tr><tr id="type-node.step" class="anchored"><td class="def field"><a href="#type-node.step" class="anchor"></a><code>step : <a href="index.html#type-step">step</a>;</code></td><td class="doc"><p>(** The reasoning step used to prove the conclusion *)</p></td></tr></table><code>}</code><code></code></div><div class="doc"><p>A proof can be expanded into a proof node, which show the first step of the proof.</p></div></div><div class="spec type" id="type-step"><a href="#type-step" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>step</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-step.Hypothesis" class="anchored"><td class="def constructor"><a href="#type-step.Hypothesis" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Hypothesis</span></code></td><td class="doc"><p>(** The conclusion is a user-provided hypothesis *)</p></td></tr><tr id="type-step.Assumption" class="anchored"><td class="def constructor"><a href="#type-step.Assumption" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Assumption</span></code></td><td class="doc"><p>(** The conclusion has been locally assumed by the user *)</p></td></tr><tr id="type-step.Lemma" class="anchored"><td class="def constructor"><a href="#type-step.Lemma" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Lemma</span><span class="keyword"> of </span><a href="../Solver_types/index.html#type-lemma">Mc2_core__.Solver_types.lemma</a></code></td><td class="doc"><p>(** The conclusion is a tautology provided by the theory, with associated proof *)</p></td></tr><tr id="type-step.Simplify" class="anchored"><td class="def constructor"><a href="#type-step.Simplify" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Simplify</span><span class="keyword"> of </span></code><code>{</code><table class="record"><tr id="type-step.init" class="anchored"><td class="def field"><a href="#type-step.init" class="anchor"></a><code>init : <a href="index.html#type-t">t</a>;</code></td></tr><tr id="type-step.duplicates" class="anchored"><td class="def field"><a href="#type-step.duplicates" class="anchor"></a><code>duplicates : <a href="../Solver_types/index.html#type-atom">Mc2_core__.Solver_types.atom</a> list;</code></td></tr><tr id="type-step.absurd" class="anchored"><td class="def field"><a href="#type-step.absurd" class="anchor"></a><code>absurd : <a href="../Solver_types/index.html#type-atom">Mc2_core__.Solver_types.atom</a> list;</code></td></tr></table><code>}</code><code></code></td><td class="doc"><p>(** The conclusion is obtained by eliminating multiple occurrences of atoms in
the conclusion of the provided proof, and removing some absurd atoms. *)</p></td></tr><tr id="type-step.Hyper_res" class="anchored"><td class="def constructor"><a href="#type-step.Hyper_res" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Hyper_res</span><span class="keyword"> of </span></code><code>{</code><table class="record"><tr id="type-step.init" class="anchored"><td class="def field"><a href="#type-step.init" class="anchor"></a><code>init : <a href="index.html#type-t">t</a>;</code></td></tr><tr id="type-step.steps" class="anchored"><td class="def field"><a href="#type-step.steps" class="anchor"></a><code>steps : <a href="../Solver_types/index.html#type-premise_step">Mc2_core__.Solver_types.premise_step</a> list;</code></td></tr></table><code>}</code><code></code></td><td class="doc"><p>(** The conclusion can be deduced by performing a series of resolution steps
between <code class="code">init</code> and, successively, each clause in the list on the
corresponding pivot atom. *)</p></td></tr></table><code></code></div><div class="doc"><p>A proof can be expanded into a proof node, which show the first step of the proof.</p><p>The type of reasoning steps allowed in a proof.</p></div></div><div class="spec val" id="val-conclusion"><a href="#val-conclusion" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>conclusion : <a href="index.html#type-node">node</a> <span class="keyword">&#8209;&gt;</span> <a href="../Solver_types/index.html#type-clause">Mc2_core__.Solver_types.clause</a></code></div><div class="doc"></div></div><div class="spec val" id="val-step"><a href="#val-step" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>step : <a href="index.html#type-node">node</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-step">step</a></code></div><div class="doc"></div></div><h4>Proof building functions</h4><div class="spec val" id="val-prove"><a href="#val-prove" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>prove : <a href="../Solver_types/index.html#type-clause">Mc2_core__.Solver_types.clause</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Given a clause, return a proof of that clause.</p><ul class="at-tag"><li><span class="at-tag raise">Raises</span> <span class="module-path">Util.Error</span>: if it does not succeed.</li></ul></div></div><div class="spec val" id="val-prove_unsat"><a href="#val-prove_unsat" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>prove_unsat : <a href="../Solver_types/index.html#type-clause">Mc2_core__.Solver_types.clause</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Given a conflict clause <code class="code">c</code>, returns a proof of the empty clause.</p><ul class="at-tag"><li><span class="at-tag raise">Raises</span> <span class="module-path">Util.Error</span>: if it does not succeed</li></ul></div></div><div class="spec val" id="val-prove_atom"><a href="#val-prove_atom" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>prove_atom : <a href="../Solver_types/index.html#type-atom">Mc2_core__.Solver_types.atom</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> option</code></div><div class="doc"><p>Given an atom <code class="code">a</code>, returns a proof of the clause <code class="code">[a]</code> if <code class="code">a</code> is true at level 0</p></div></div><h4>Proof Nodes</h4><div class="spec val" id="val-is_leaf"><a href="#val-is_leaf" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>is_leaf : <a href="index.html#type-step">step</a> <span class="keyword">&#8209;&gt;</span> bool</code></div><div class="doc"><p>Returns whether the proof node is a leaf, i.e. an hypothesis,
an assumption, or a lemma.
<code class="code">true</code> if and only if  returns the empty list.</p></div></div><div class="spec val" id="val-expl"><a href="#val-expl" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>expl : <a href="index.html#type-step">step</a> <span class="keyword">&#8209;&gt;</span> string</code></div><div class="doc"><p>Returns a short string description for the proof step; for instance
<code class="code">&quot;hypothesis&quot;</code> for a <code class="code">Hypothesis</code>
(it currently returns the variant name in lowercase).</p></div></div><div class="spec val" id="val-parents"><a href="#val-parents" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>parents : <a href="index.html#type-step">step</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> list</code></div><div class="doc"><p>Returns the parents of a proof node.</p></div></div><h4>Proof Manipulation</h4><div class="spec val" id="val-expand"><a href="#val-expand" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>expand : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-node">node</a></code></div><div class="doc"><p>Return the proof step at the root of a given proof.</p></div></div><div class="spec val" id="val-fold"><a href="#val-fold" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>fold : (<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-node">node</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span>) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span></code></div><div class="doc"><p><code class="code">fold f acc p</code>, fold <code class="code">f</code> over the proof <code class="code">p</code> and all its node. It is guaranteed that
<code class="code">f</code> is executed exactly once on each proof node in the tree, and that the execution of
<code class="code">f</code> on a proof node happens after the execution on the parents of the nodes.</p></div></div><div class="spec val" id="val-iter"><a href="#val-iter" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>iter : (<a href="index.html#type-node">node</a> <span class="keyword">&#8209;&gt;</span> unit) <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"></div></div><div class="spec val" id="val-unsat_core"><a href="#val-unsat_core" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>unsat_core : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="../Solver_types/index.html#type-clause">Mc2_core__.Solver_types.clause</a> list</code></div><div class="doc"><p>Returns the unsat_core of the given proof, i.e the lists of conclusions of all leafs of the proof.
More efficient than using the <code class="code">fold</code> function since it has access to the internal representation of proofs</p></div></div><div class="spec val" id="val-debug_step"><a href="#val-debug_step" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>debug_step : <a href="index.html#type-step">step</a> CCFormat.printer</code></div><div class="doc"></div></div><h4>Misc</h4><div class="spec val" id="val-check"><a href="#val-check" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>check : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p>Check the contents of a proof. Mainly for internal use</p></div></div><h4>Unsafe</h4><div class="spec module" id="module-H"><a href="#module-H" class="anchor"></a><div class="def module"><code><span class="keyword">module </span>H : Hashtbl.S<span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-H">H</a>.key<span class="keyword"> = </span><a href="../Solver_types/index.html#type-clause">Mc2_core__.Solver_types.clause</a></code></div><div class="doc"><p>Hashtable over clauses. Uses the details of the internal representation
to achieve the best performances, however hashtables from this module
become invalid when solving is restarted, so they should only be live
during inspection of a single proof.</p></div></div></body></html>