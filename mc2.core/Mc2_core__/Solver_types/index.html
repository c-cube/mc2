<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Solver_types (mc2.core.Mc2_core__.Solver_types)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../index.html">mc2.core</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Mc2_core__.Solver_types</span></h1></header><p>Internal types (implementation)</p><p>This modules actually implements the internal types used by the solver.
Since mutation is heavily used in the solver, it is really, really, *really*
discouraged to direclty use the functions in this module if you don't know the
inner working of mSAT perfectly as even the simplest
change can have dramatic effects on the solver.</p><p>Internal types (interface)</p><p>This modules defines the interface of most of the internal types
used in the core solver.</p><div class="spec module" id="module-Term_fields"><a href="#module-Term_fields" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Term_fields/index.html">Term_fields</a> : <a href="../../Mc2_core__BitField/index.html#module-type-S">Mc2_core__BitField.S</a></code></div><div class="doc"></div></div><div class="spec module" id="module-Clause_fields"><a href="#module-Clause_fields" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Clause_fields/index.html">Clause_fields</a> : <a href="../../Mc2_core__BitField/index.html#module-type-S">Mc2_core__BitField.S</a></code></div><div class="doc"></div></div><div class="spec module" id="module-Fmt"><a href="#module-Fmt" class="anchor"></a><div class="def module"><code><span class="keyword">module </span>Fmt = CCFormat</code></div><div class="doc"></div></div><div class="spec module" id="module-Int_map"><a href="#module-Int_map" class="anchor"></a><div class="def module"><code><span class="keyword">module </span>Int_map = <a href="../../Mc2_core/Util/index.html#module-Int_map">Mc2_core.Util.Int_map</a></code></div><div class="doc"></div></div><h3>Type definitions</h3><div class="spec type" id="type-plugin_id"><a href="#type-plugin_id" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>plugin_id</code><code><span class="keyword"> = </span>int</code><code></code></div><div class="doc"></div></div><div class="spec type" id="type-level"><a href="#type-level" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>level</code><code><span class="keyword"> = </span>int</code><code></code></div><div class="doc"></div></div><div class="spec type" id="type-term_view"><a href="#type-term_view" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>term_view</code><code></code><code><span class="keyword"> = </span></code><code><span class="keyword">..</span></code><code></code></div><div class="doc"><p>Extensible view on terms (generalized variables).
Each plugin might declare its own terms.</p></div></div><div class="spec type" id="type-value_view"><a href="#type-value_view" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>value_view</code><code></code><code><span class="keyword"> = </span></code><code><span class="keyword">..</span></code><code></code></div><div class="doc"><p>Extensible view on values.</p></div></div><div class="spec type" id="type-decide_state"><a href="#type-decide_state" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>decide_state</code><code></code><code><span class="keyword"> = </span></code><code><span class="keyword">..</span></code><code></code></div><div class="doc"><p>State carried by a given term, depending on its type, and used
for decisions and propagations related to the term.
Typically it contains a set of constraints on the values this
term can have (lower/upper bounds, etc.)</p></div></div><div class="spec type" id="type-lemma_view"><a href="#type-lemma_view" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>lemma_view</code><code></code><code><span class="keyword"> = </span></code><code><span class="keyword">..</span></code><code></code></div><div class="doc"><p>Extensible proof object</p></div></div><div class="spec type" id="type-ty_view"><a href="#type-ty_view" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>ty_view</code><code></code><code><span class="keyword"> = </span></code><code><span class="keyword">..</span></code><code></code></div><div class="doc"><p>Extensible view on types</p></div></div><div class="spec type" id="type-ty"><a href="#type-ty" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>ty</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-ty.Bool" class="anchored"><td class="def constructor"><a href="#type-ty.Bool" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Bool</span></code></td><td class="doc"><p>(** Builtin type of booleans *)</p></td></tr><tr id="type-ty.Ty" class="anchored"><td class="def constructor"><a href="#type-ty.Ty" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Ty</span><span class="keyword"> of </span></code><code>{</code><table class="record"><tr id="type-ty.id" class="anchored"><td class="def field"><a href="#type-ty.id" class="anchor"></a><code><span class="keyword">mutable </span>id : int;</code></td><td class="doc"><p>(** unique ID of the type *)</p></td></tr><tr id="type-ty.view" class="anchored"><td class="def field"><a href="#type-ty.view" class="anchor"></a><code>view : <a href="index.html#type-ty_view">ty_view</a>;</code></td></tr><tr id="type-ty.tc" class="anchored"><td class="def field"><a href="#type-ty.tc" class="anchor"></a><code>tc : <a href="index.html#type-tc_ty">tc_ty</a>;</code></td><td class="doc"><p>(** operations *)</p></td></tr></table><code>}</code><code></code></td><td class="doc"><p>(** An atomic type, with some attached data *)</p></td></tr></table><code></code></div><div class="doc"><p>Types</p></div></div><div class="spec type" id="type-tc_ty"><a href="#type-tc_ty" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>tc_ty</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-tc_ty.tcty_decide" class="anchored"><td class="def field"><a href="#type-tc_ty.tcty_decide" class="anchor"></a><code>tcty_decide : <a href="index.html#type-actions">actions</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-term">term</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-value">value</a>;</code></td><td class="doc"><p>(** How to make semantic decisions for terms of this type? *)</p></td></tr><tr id="type-tc_ty.tcty_eq" class="anchored"><td class="def field"><a href="#type-tc_ty.tcty_eq" class="anchor"></a><code>tcty_eq : <a href="index.html#type-term">term</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-term">term</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-term">term</a>;</code></td></tr><tr id="type-tc_ty.tcty_pp" class="anchored"><td class="def field"><a href="#type-tc_ty.tcty_pp" class="anchor"></a><code>tcty_pp : <a href="index.html#type-ty_view">ty_view</a> CCFormat.printer;</code></td><td class="doc"><p>(** print types *)</p></td></tr><tr id="type-tc_ty.tcty_mk_state" class="anchored"><td class="def field"><a href="#type-tc_ty.tcty_mk_state" class="anchor"></a><code>tcty_mk_state : unit <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-decide_state">decide_state</a>;</code></td><td class="doc"><p>(** decide state for a new term *)</p></td></tr></table><code>}</code><code></code></div><div class="doc"></div></div><div class="spec type" id="type-term"><a href="#type-term" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>term</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-term.t_tc" class="anchored"><td class="def field"><a href="#type-term.t_tc" class="anchor"></a><code>t_tc : <a href="index.html#type-tc_term">tc_term</a>;</code></td><td class="doc"><p>(** typeclass for the term *)</p></td></tr><tr id="type-term.t_id" class="anchored"><td class="def field"><a href="#type-term.t_id" class="anchor"></a><code><span class="keyword">mutable </span>t_id : int;</code></td><td class="doc"><p>(** unique ID, made of:
</p><ul><li><code class="code">k</code> bits plugin_id (with k small)</li><li>the rest is for plugin-specific id</li></ul><p> *)</p></td></tr><tr id="type-term.t_view" class="anchored"><td class="def field"><a href="#type-term.t_view" class="anchor"></a><code>t_view : <a href="index.html#type-term_view">term_view</a>;</code></td><td class="doc"><p>(** view *)</p></td></tr><tr id="type-term.t_ty" class="anchored"><td class="def field"><a href="#type-term.t_ty" class="anchor"></a><code>t_ty : <a href="index.html#type-ty">ty</a>;</code></td><td class="doc"><p>(** type of the term *)</p></td></tr><tr id="type-term.t_idx" class="anchored"><td class="def field"><a href="#type-term.t_idx" class="anchor"></a><code><span class="keyword">mutable </span>t_idx : int;</code></td><td class="doc"><p>(** position in heap *)</p></td></tr><tr id="type-term.t_weight" class="anchored"><td class="def field"><a href="#type-term.t_weight" class="anchor"></a><code><span class="keyword">mutable </span>t_weight : float;</code></td><td class="doc"><p>(** Weight (for the heap), tracking activity *)</p></td></tr><tr id="type-term.t_fields" class="anchored"><td class="def field"><a href="#type-term.t_fields" class="anchor"></a><code><span class="keyword">mutable </span>t_fields : <a href="Term_fields/index.html#type-t">Term_fields.t</a>;</code></td><td class="doc"><p>(** bitfield for storing various info *)</p></td></tr><tr id="type-term.t_var" class="anchored"><td class="def field"><a href="#type-term.t_var" class="anchor"></a><code><span class="keyword">mutable </span>t_var : <a href="index.html#type-var">var</a>;</code></td><td class="doc"><p>(** The &quot;generalized variable&quot; part, for assignments. *)</p></td></tr><tr id="type-term.t_watches" class="anchored"><td class="def field"><a href="#type-term.t_watches" class="anchor"></a><code><span class="keyword">mutable </span>t_watches : <a href="index.html#type-term">term</a> <a href="../Vec/index.html#type-t">Mc2_core__.Vec.t</a> lazy_t;</code></td><td class="doc"><p>(** terms that watch this term *)</p></td></tr><tr id="type-term.t_assign" class="anchored"><td class="def field"><a href="#type-term.t_assign" class="anchor"></a><code><span class="keyword">mutable </span>t_assign : <a href="index.html#type-term_assignment">term_assignment</a>;</code></td><td class="doc"><p>(** current assignment *)</p></td></tr></table><code>}</code><code></code></div><div class="doc"><p>Main term representation. A <a href="index.html#type-term">term</a>, contains almost all information
necessary to process it, including:</p><ul><li>its unique ID</li><li>its plugin-specific representation (possibly with subterms)</li><li>its current assignment, level, weight, etc.</li><li>some info related to its position in the queue of terms to decide</li></ul><p>It is worth noting that terms are also (generalized) <i>variables</i>
and behave mostly the same as boolean variables for the main
solver, meaning that they need to be assigned a value in the model.</p></div></div><div class="spec type" id="type-tc_term"><a href="#type-tc_term" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>tc_term</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-tc_term.tct_pp" class="anchored"><td class="def field"><a href="#type-tc_term.tct_pp" class="anchor"></a><code>tct_pp : <a href="index.html#type-term_view">term_view</a> CCFormat.printer;</code></td><td class="doc"><p>(** print views of this plugin *)</p></td></tr><tr id="type-tc_term.tct_init" class="anchored"><td class="def field"><a href="#type-tc_term.tct_init" class="anchor"></a><code>tct_init : <a href="index.html#type-actions">actions</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-term">term</a> <span class="keyword">&#8209;&gt;</span> unit;</code></td><td class="doc"><p>(** called when term is added *)</p></td></tr><tr id="type-tc_term.tct_update_watches" class="anchored"><td class="def field"><a href="#type-tc_term.tct_update_watches" class="anchor"></a><code>tct_update_watches : <a href="index.html#type-actions">actions</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-term">term</a> <span class="keyword">&#8209;&gt;</span> watch:<a href="index.html#type-term">term</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-watch_res">watch_res</a>;</code></td><td class="doc"><p>(** <code class="code">watch</code> was assign, update term <code class="code">t</code>, and return whether <code class="code">t</code> should
still watch <code class="code">watch</code> *)</p></td></tr><tr id="type-tc_term.tct_delete" class="anchored"><td class="def field"><a href="#type-tc_term.tct_delete" class="anchor"></a><code>tct_delete : <a href="index.html#type-term">term</a> <span class="keyword">&#8209;&gt;</span> unit;</code></td><td class="doc"><p>(** called when term is deleted *)</p></td></tr><tr id="type-tc_term.tct_subterms" class="anchored"><td class="def field"><a href="#type-tc_term.tct_subterms" class="anchor"></a><code>tct_subterms : <a href="index.html#type-term_view">term_view</a> <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-term">term</a> <span class="keyword">&#8209;&gt;</span> unit) <span class="keyword">&#8209;&gt;</span> unit;</code></td><td class="doc"><p>(** iterate on subterms *)</p></td></tr><tr id="type-tc_term.tct_eval" class="anchored"><td class="def field"><a href="#type-tc_term.tct_eval" class="anchor"></a><code>tct_eval : <a href="index.html#type-term">term</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-eval_res">eval_res</a>;</code></td><td class="doc"><p>(** Evaluate term *)</p></td></tr></table><code>}</code><code></code></div><div class="doc"><p>type class for terms, packing all operations on terms</p></div></div><div class="spec type" id="type-watch_res"><a href="#type-watch_res" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>watch_res</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-watch_res.Watch_keep" class="anchored"><td class="def constructor"><a href="#type-watch_res.Watch_keep" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Watch_keep</span></code></td><td class="doc"><p>(** Keep the watch *)</p></td></tr><tr id="type-watch_res.Watch_remove" class="anchored"><td class="def constructor"><a href="#type-watch_res.Watch_remove" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Watch_remove</span></code></td><td class="doc"><p>(** Remove the watch *)</p></td></tr></table><code></code></div><div class="doc"></div></div><div class="spec type" id="type-eval_res"><a href="#type-eval_res" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>eval_res</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-eval_res.Eval_unknown" class="anchored"><td class="def constructor"><a href="#type-eval_res.Eval_unknown" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Eval_unknown</span></code></td><td class="doc"><p>(** The given formula does not have an evaluation *)</p></td></tr><tr id="type-eval_res.Eval_into" class="anchored"><td class="def constructor"><a href="#type-eval_res.Eval_into" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Eval_into</span><span class="keyword"> of </span><a href="index.html#type-value">value</a><span class="keyword"> * </span><a href="index.html#type-term">term</a> list</code></td><td class="doc"><p>(** The given formula can be evaluated to the given value.
The list of terms to give is the list of terms that were effectively used
for the evaluation. *)</p></td></tr></table><code></code></div><div class="doc"><p>The type of evaluation results for a given formula.
For instance, let's suppose we want to evaluate the formula <code class="code">x * y = 0</code>, the
following result are correct:
</p><ul><li><code class="code">Unknown</code> if neither <code class="code">x</code> nor <code class="code">y</code> are assigned to a value</li><li><code class="code">Valued (true, [x])</code> if <code class="code">x</code> is assigned to <code class="code">0</code></li><li><code class="code">Valued (true, [y])</code> if <code class="code">y</code> is assigned to <code class="code">0</code></li><li><code class="code">Valued (false, [x; y])</code> if <code class="code">x</code> and <code class="code">y</code> are assigned to 1 (or any non-zero number)</li></ul></div></div><div class="spec type" id="type-check_res"><a href="#type-check_res" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>check_res</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-check_res.Sat" class="anchored"><td class="def constructor"><a href="#type-check_res.Sat" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Sat</span></code></td><td class="doc"><p>(** The current set of assumptions is satisfiable. *)</p></td></tr><tr id="type-check_res.Unsat" class="anchored"><td class="def constructor"><a href="#type-check_res.Unsat" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Unsat</span><span class="keyword"> of </span><a href="index.html#type-atom">atom</a> list<span class="keyword"> * </span><a href="index.html#type-lemma">lemma</a></code></td><td class="doc"><p>(** The current set of assumptions is *NOT* satisfiable, and here is a
theory tautology (with its proof), for which every literal is false
under the current assumptions. *)</p></td></tr></table><code></code></div><div class="doc"></div></div><div class="spec type" id="type-value"><a href="#type-value" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>value</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-value.V_true" class="anchored"><td class="def constructor"><a href="#type-value.V_true" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">V_true</span></code></td></tr><tr id="type-value.V_false" class="anchored"><td class="def constructor"><a href="#type-value.V_false" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">V_false</span></code></td></tr><tr id="type-value.V_value" class="anchored"><td class="def constructor"><a href="#type-value.V_value" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">V_value</span><span class="keyword"> of </span></code><code>{</code><table class="record"><tr id="type-value.view" class="anchored"><td class="def field"><a href="#type-value.view" class="anchor"></a><code>view : <a href="index.html#type-value_view">value_view</a>;</code></td><td class="doc"><p>(** Actual shape of the value *)</p></td></tr><tr id="type-value.tc" class="anchored"><td class="def field"><a href="#type-value.tc" class="anchor"></a><code>tc : <a href="index.html#type-tc_value">tc_value</a>;</code></td><td class="doc"><p>(** typeclass for values *)</p></td></tr></table><code>}</code><code></code></td><td class="doc"><p>(** A semantic value, part of the model's domain.
For arithmetic, it would
be a number; for arrays, a finite map + default value; etc.
Note that terms map to values in the model but that values are
not necessarily normal &quot;terms&quot; (i.e. generalized variables in
the MCSat sense). *)</p></td></tr></table><code></code></div><div class="doc"><p>A value, either boolean or semantic</p></div></div><div class="spec type" id="type-var"><a href="#type-var" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>var</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-var.Var_semantic" class="anchored"><td class="def constructor"><a href="#type-var.Var_semantic" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Var_semantic</span><span class="keyword"> of </span></code><code>{</code><table class="record"><tr id="type-var.v_decide_state" class="anchored"><td class="def field"><a href="#type-var.v_decide_state" class="anchor"></a><code><span class="keyword">mutable </span>v_decide_state : <a href="index.html#type-decide_state">decide_state</a>;</code></td><td class="doc"><p>(** used for decisions/assignments *)</p></td></tr></table><code>}</code><code></code></td><td class="doc"><p>(** Semantic variable *)</p></td></tr><tr id="type-var.Var_bool" class="anchored"><td class="def constructor"><a href="#type-var.Var_bool" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Var_bool</span><span class="keyword"> of </span></code><code>{</code><table class="record"><tr id="type-var.pa" class="anchored"><td class="def field"><a href="#type-var.pa" class="anchor"></a><code>pa : <a href="index.html#type-atom">atom</a>;</code></td><td class="doc"><p>(** Link for the positive atom *)</p></td></tr><tr id="type-var.na" class="anchored"><td class="def field"><a href="#type-var.na" class="anchor"></a><code>na : <a href="index.html#type-atom">atom</a>;</code></td><td class="doc"><p>(** Link for the negative atom *)</p></td></tr></table><code>}</code><code></code></td><td class="doc"><p>(** Bool variable *)</p></td></tr><tr id="type-var.Var_none" class="anchored"><td class="def constructor"><a href="#type-var.Var_none" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Var_none</span></code></td><td class="doc"><p>(** Not a variable yet (not added) *)</p></td></tr></table><code></code></div><div class="doc"><p>The &quot;generalized variable&quot; part of a term, containing the
current assignment, watched literals/terms, etc.</p></div></div><div class="spec type" id="type-atom"><a href="#type-atom" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>atom</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-atom.a_id" class="anchored"><td class="def field"><a href="#type-atom.a_id" class="anchor"></a><code>a_id : int;</code></td><td class="doc"><p>(** Unique identifier *)</p></td></tr><tr id="type-atom.a_term" class="anchored"><td class="def field"><a href="#type-atom.a_term" class="anchor"></a><code>a_term : <a href="index.html#type-term">term</a>;</code></td><td class="doc"><p>(** Link for the parent variable *)</p></td></tr><tr id="type-atom.a_watched" class="anchored"><td class="def field"><a href="#type-atom.a_watched" class="anchor"></a><code><span class="keyword">mutable </span>a_watched : <a href="index.html#type-clause">clause</a> <a href="../Vec/index.html#type-t">Mc2_core__.Vec.t</a>;</code></td><td class="doc"><p>(** The vector of clauses that watch this atom *)</p></td></tr></table><code>}</code><code></code></div><div class="doc"><p>Atoms and variables wrap theory formulas. They exist in the form of
triplet: a variable and two atoms. For a formula <code class="code">f</code> in normal form,
the variable v points to the positive atom <code class="code">a</code> which wraps <code class="code">f</code>, while
<code class="code">a.neg</code> wraps the theory negation of <code class="code">f</code>.</p></div></div><div class="spec type" id="type-term_assignment"><a href="#type-term_assignment" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>term_assignment</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-term_assignment.TA_none" class="anchored"><td class="def constructor"><a href="#type-term_assignment.TA_none" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">TA_none</span></code></td></tr><tr id="type-term_assignment.TA_assign" class="anchored"><td class="def constructor"><a href="#type-term_assignment.TA_assign" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">TA_assign</span><span class="keyword"> of </span></code><code>{</code><table class="record"><tr id="type-term_assignment.level" class="anchored"><td class="def field"><a href="#type-term_assignment.level" class="anchor"></a><code>level : int;</code></td><td class="doc"><p>(** Decision level of the assignment *)</p></td></tr><tr id="type-term_assignment.value" class="anchored"><td class="def field"><a href="#type-term_assignment.value" class="anchor"></a><code>value : <a href="index.html#type-value">value</a>;</code></td></tr><tr id="type-term_assignment.reason" class="anchored"><td class="def field"><a href="#type-term_assignment.reason" class="anchor"></a><code>reason : <a href="index.html#type-reason">reason</a>;</code></td></tr></table><code>}</code><code></code></td></tr></table><code></code></div><div class="doc"><p>The value(s) and reason(s) for propagation/decision
and evaluation of the term</p></div></div><div class="spec type" id="type-clause"><a href="#type-clause" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>clause</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-clause.c_name" class="anchored"><td class="def field"><a href="#type-clause.c_name" class="anchor"></a><code>c_name : int;</code></td><td class="doc"><p>(** Clause name, mainly for printing, unique. *)</p></td></tr><tr id="type-clause.c_tag" class="anchored"><td class="def field"><a href="#type-clause.c_tag" class="anchor"></a><code>c_tag : int option;</code></td><td class="doc"><p>(** User-provided tag for clauses. *)</p></td></tr><tr id="type-clause.c_atoms" class="anchored"><td class="def field"><a href="#type-clause.c_atoms" class="anchor"></a><code>c_atoms : <a href="index.html#type-atom">atom</a> array;</code></td><td class="doc"><p>(** The atoms that constitute the clause. *)</p></td></tr><tr id="type-clause.c_premise" class="anchored"><td class="def field"><a href="#type-clause.c_premise" class="anchor"></a><code><span class="keyword">mutable </span>c_premise : <a href="index.html#type-premise">premise</a>;</code></td><td class="doc"><p>(** The premise of the clause, i.e. the justification of why the clause must
be satisfied. *)</p></td></tr><tr id="type-clause.c_activity" class="anchored"><td class="def field"><a href="#type-clause.c_activity" class="anchor"></a><code><span class="keyword">mutable </span>c_activity : float;</code></td><td class="doc"><p>(** Clause activity, used for the heap heuristics. *)</p></td></tr><tr id="type-clause.c_fields" class="anchored"><td class="def field"><a href="#type-clause.c_fields" class="anchor"></a><code><span class="keyword">mutable </span>c_fields : <a href="Clause_fields/index.html#type-t">Clause_fields.t</a>;</code></td><td class="doc"><p>(** bitfield for clauses *)</p></td></tr></table><code>}</code><code></code></div><div class="doc"><p>The type of clauses. Each clause generated should be true, i.e. enforced
by the current problem (for more information, see the cpremise field).</p></div></div><div class="spec type" id="type-paramod_clause"><a href="#type-paramod_clause" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>paramod_clause</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-paramod_clause.pc_lhs" class="anchored"><td class="def field"><a href="#type-paramod_clause.pc_lhs" class="anchor"></a><code>pc_lhs : <a href="index.html#type-term">term</a>;</code></td></tr><tr id="type-paramod_clause.pc_rhs" class="anchored"><td class="def field"><a href="#type-paramod_clause.pc_rhs" class="anchor"></a><code>pc_rhs : <a href="index.html#type-term">term</a>;</code></td></tr><tr id="type-paramod_clause.pc_guard" class="anchored"><td class="def field"><a href="#type-paramod_clause.pc_guard" class="anchor"></a><code>pc_guard : <a href="index.html#type-atom">atom</a> list;</code></td></tr><tr id="type-paramod_clause.pc_premise" class="anchored"><td class="def field"><a href="#type-paramod_clause.pc_premise" class="anchor"></a><code>pc_premise : <a href="index.html#type-premise">premise</a>;</code></td></tr><tr id="type-paramod_clause.pc_clause" class="anchored"><td class="def field"><a href="#type-paramod_clause.pc_clause" class="anchor"></a><code>pc_clause : <a href="index.html#type-clause">clause</a> lazy_t;</code></td><td class="doc"><p>(** view as a clause *)</p></td></tr></table><code>}</code><code></code></div><div class="doc"><p>A paramodulation clause, of the form <code class="code">guard =&gt; (lhs = rhs)</code>. It is
used to rewrite <code class="code">lhs</code> into <code class="code">rhs</code> assuming <code class="code">guard</code> holds</p></div></div><div class="spec type" id="type-tc_value"><a href="#type-tc_value" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>tc_value</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-tc_value.tcv_pp" class="anchored"><td class="def field"><a href="#type-tc_value.tcv_pp" class="anchor"></a><code>tcv_pp : <a href="index.html#type-value_view">value_view</a> CCFormat.printer;</code></td><td class="doc"><p>(** printer *)</p></td></tr><tr id="type-tc_value.tcv_equal" class="anchored"><td class="def field"><a href="#type-tc_value.tcv_equal" class="anchor"></a><code>tcv_equal : <a href="index.html#type-value_view">value_view</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-value_view">value_view</a> <span class="keyword">&#8209;&gt;</span> bool;</code></td><td class="doc"><p>(** equality *)</p></td></tr><tr id="type-tc_value.tcv_hash" class="anchored"><td class="def field"><a href="#type-tc_value.tcv_hash" class="anchor"></a><code>tcv_hash : <a href="index.html#type-value_view">value_view</a> <span class="keyword">&#8209;&gt;</span> int;</code></td><td class="doc"><p>(** hash function *)</p></td></tr></table><code>}</code><code></code></div><div class="doc"><p>Methods for values</p></div></div><div class="spec type" id="type-reason"><a href="#type-reason" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>reason</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-reason.Decision" class="anchored"><td class="def constructor"><a href="#type-reason.Decision" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Decision</span></code></td><td class="doc"><p>(** The atom has been decided by the sat solver *)</p></td></tr><tr id="type-reason.Bcp" class="anchored"><td class="def constructor"><a href="#type-reason.Bcp" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Bcp</span><span class="keyword"> of </span><a href="index.html#type-clause">clause</a></code></td><td class="doc"><p>(** The atom has been propagated by the given clause *)</p></td></tr><tr id="type-reason.Bcp_lazy" class="anchored"><td class="def constructor"><a href="#type-reason.Bcp_lazy" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Bcp_lazy</span><span class="keyword"> of </span><a href="index.html#type-clause">clause</a> lazy_t</code></td><td class="doc"><p>(** Same as <a href="index.html#type-reason.Bcp">Bcp</a> but the clause is produced on demand
(typically, useful for theory propagation) *)</p></td></tr><tr id="type-reason.Eval" class="anchored"><td class="def constructor"><a href="#type-reason.Eval" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Eval</span><span class="keyword"> of </span><a href="index.html#type-term">term</a> list</code></td><td class="doc"><p>(** The term can be evaluated using the terms in the list. Each
term has a value. *)</p></td></tr></table><code></code></div><div class="doc"><p>Reasons of propagation/decision of atoms/terms.</p></div></div><div class="spec type" id="type-premise"><a href="#type-premise" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>premise</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-premise.Hyp" class="anchored"><td class="def constructor"><a href="#type-premise.Hyp" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Hyp</span></code></td><td class="doc"><p>(** The clause is a hypothesis, provided by the user. *)</p></td></tr><tr id="type-premise.Local" class="anchored"><td class="def constructor"><a href="#type-premise.Local" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Local</span></code></td><td class="doc"><p>(** The clause is a 1-atom clause, where the atom is a local assumption *)</p></td></tr><tr id="type-premise.Lemma" class="anchored"><td class="def constructor"><a href="#type-premise.Lemma" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Lemma</span><span class="keyword"> of </span><a href="index.html#type-lemma">lemma</a></code></td><td class="doc"><p>(** The clause is a theory-provided tautology, with the given proof. *)</p></td></tr><tr id="type-premise.Simplify" class="anchored"><td class="def constructor"><a href="#type-premise.Simplify" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Simplify</span><span class="keyword"> of </span><a href="index.html#type-clause">clause</a></code></td><td class="doc"><p>(** Deduplication/sorting of atoms in the clause *)</p></td></tr><tr id="type-premise.P_steps" class="anchored"><td class="def constructor"><a href="#type-premise.P_steps" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">P_steps</span><span class="keyword"> of </span></code><code>{</code><table class="record"><tr id="type-premise.init" class="anchored"><td class="def field"><a href="#type-premise.init" class="anchor"></a><code>init : <a href="index.html#type-clause">clause</a>;</code></td></tr><tr id="type-premise.steps" class="anchored"><td class="def field"><a href="#type-premise.steps" class="anchor"></a><code>steps : <a href="index.html#type-premise_step">premise_step</a> list;</code></td></tr></table><code>}</code><code></code></td></tr><tr id="type-premise.P_raw_steps" class="anchored"><td class="def constructor"><a href="#type-premise.P_raw_steps" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">P_raw_steps</span><span class="keyword"> of </span><a href="index.html#type-raw_premise_step">raw_premise_step</a> list</code></td><td class="doc"><p>(** The clause can be obtained by resolution or paramodulation of the clauses
in the list, left-to-right.
For a premise <code class="code">History [a_1 :: ... :: a_n]</code> (<code class="code">n &gt;= 2</code>) the clause
is obtained by performing resolution of <code class="code">a_1</code> with <code class="code">a_2</code>, and then
performing a resolution step between the result and <code class="code">a_3</code>, etc... Of
course, each of the clause <code class="code">a_i</code> also has its own premise. *)</p></td></tr></table><code></code></div><div class="doc"><p>Premises for clauses. Indeed each clause generated during a run of the solver
should be satisfied, the premise is the justification of why it should be
satisfied by the solver.</p><p>The premise of a clause can be updated, during proof processing,
going from <code class="code">Hyper_res l</code> towards explicit steps of resolution
with <code class="code">Resolve</code>. This update preserves the semantics of proofs
but acts as a memoization of the proof reconstruction process.</p></div></div><div class="spec type" id="type-raw_premise_step"><a href="#type-raw_premise_step" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>raw_premise_step</code><code><span class="keyword"> = </span><a href="index.html#type-clause">clause</a></code><code></code></div><div class="doc"><p>init clause/resolution with clause</p></div></div><div class="spec type" id="type-premise_step"><a href="#type-premise_step" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>premise_step</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-premise_step.Step_resolve" class="anchored"><td class="def constructor"><a href="#type-premise_step.Step_resolve" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Step_resolve</span><span class="keyword"> of </span></code><code>{</code><table class="record"><tr id="type-premise_step.c" class="anchored"><td class="def field"><a href="#type-premise_step.c" class="anchor"></a><code>c : <a href="index.html#type-clause">clause</a>;</code></td><td class="doc"><p>(** clause to resolve with *)</p></td></tr><tr id="type-premise_step.pivot" class="anchored"><td class="def field"><a href="#type-premise_step.pivot" class="anchor"></a><code>pivot : <a href="index.html#type-term">term</a>;</code></td><td class="doc"><p>(** pivot to remove *)</p></td></tr></table><code>}</code><code></code></td></tr></table><code></code></div><div class="doc"><p>Clause or paramodulation, refined form</p></div></div><div class="spec type" id="type-lemma"><a href="#type-lemma" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>lemma</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-lemma.Lemma_bool_tauto" class="anchored"><td class="def constructor"><a href="#type-lemma.Lemma_bool_tauto" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Lemma_bool_tauto</span></code></td><td class="doc"><p>(** tautology <code class="code">a ∨ ¬a</code> *)</p></td></tr><tr id="type-lemma.Lemma_custom" class="anchored"><td class="def constructor"><a href="#type-lemma.Lemma_custom" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Lemma_custom</span><span class="keyword"> of </span></code><code>{</code><table class="record"><tr id="type-lemma.view" class="anchored"><td class="def field"><a href="#type-lemma.view" class="anchor"></a><code>view : <a href="index.html#type-lemma_view">lemma_view</a>;</code></td><td class="doc"><p>(** The lemma content *)</p></td></tr><tr id="type-lemma.tc" class="anchored"><td class="def field"><a href="#type-lemma.tc" class="anchor"></a><code>tc : <a href="index.html#type-tc_lemma">tc_lemma</a>;</code></td><td class="doc"><p>(** Methods on the lemma *)</p></td></tr></table><code>}</code><code></code></td><td class="doc"><p>(** A lemma belonging to some plugin. Must be a tautology of the theory. *)</p></td></tr></table><code></code></div><div class="doc"></div></div><div class="spec type" id="type-tc_lemma"><a href="#type-tc_lemma" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>tc_lemma</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-tc_lemma.tcl_pp" class="anchored"><td class="def field"><a href="#type-tc_lemma.tcl_pp" class="anchor"></a><code>tcl_pp : <a href="index.html#type-lemma_view">lemma_view</a> CCFormat.printer;</code></td></tr></table><code>}</code><code></code></div><div class="doc"></div></div><div class="spec type" id="type-actions"><a href="#type-actions" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>actions</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-actions.act_push_clause" class="anchored"><td class="def field"><a href="#type-actions.act_push_clause" class="anchor"></a><code>act_push_clause : <a href="index.html#type-clause">clause</a> <span class="keyword">&#8209;&gt;</span> unit;</code></td><td class="doc"><p>(** push a new clause. This clause is added to the solver and will
not be backtracked. *)</p></td></tr><tr id="type-actions.act_level" class="anchored"><td class="def field"><a href="#type-actions.act_level" class="anchor"></a><code>act_level : unit <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-level">level</a>;</code></td><td class="doc"><p>(** access current decision level *)</p></td></tr><tr id="type-actions.act_propagate_bool_eval" class="anchored"><td class="def field"><a href="#type-actions.act_propagate_bool_eval" class="anchor"></a><code>act_propagate_bool_eval : <a href="index.html#type-term">term</a> <span class="keyword">&#8209;&gt;</span> bool <span class="keyword">&#8209;&gt;</span> subs:<a href="index.html#type-term">term</a> list <span class="keyword">&#8209;&gt;</span> unit;</code></td><td class="doc"><p>(** <code class="code">act_propagate_bool_eval t b l</code> propagates the boolean literal <code class="code">t</code>
assigned to boolean value <code class="code">b</code>, explained by evaluation with
relevant (sub)terms <code class="code">l</code></p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">subs</span>: subterms used for the propagation</li></ul><p> *)</p></td></tr><tr id="type-actions.act_propagate_bool_lemma" class="anchored"><td class="def field"><a href="#type-actions.act_propagate_bool_lemma" class="anchor"></a><code>act_propagate_bool_lemma : <a href="index.html#type-term">term</a> <span class="keyword">&#8209;&gt;</span> bool <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-atom">atom</a> list <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-lemma">lemma</a> <span class="keyword">&#8209;&gt;</span> unit;</code></td><td class="doc"><p>(** <code class="code">act_propagate_bool_lemma t b c</code> propagates the boolean literal <code class="code">t</code>
assigned to boolean value <code class="code">b</code>, explained by a valid theory
lemma <code class="code">c</code>.
Precondition: <code class="code">c</code> is a tautology such that <code class="code">c == (c' ∨ t=b)</code>, where <code class="code">c'</code>
is composed of atoms false in current model. *)</p></td></tr><tr id="type-actions.act_raise_conflict" class="anchored"><td class="def field"><a href="#type-actions.act_raise_conflict" class="anchor"></a><code>act_raise_conflict : a. <a href="index.html#type-atom">atom</a> list <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-lemma">lemma</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span>;</code></td><td class="doc"><p>(** Raise a conflict with the given clause, which must be false
in the current trail, and with a lemma to explain *)</p></td></tr><tr id="type-actions.act_on_backtrack" class="anchored"><td class="def field"><a href="#type-actions.act_on_backtrack" class="anchor"></a><code>act_on_backtrack : (unit <span class="keyword">&#8209;&gt;</span> unit) <span class="keyword">&#8209;&gt;</span> unit;</code></td><td class="doc"><p>(** <code class="code">act_on_backtrack f</code> will call <code class="code">f</code> when we backtrack *)</p></td></tr></table><code>}</code><code></code></div><div class="doc"><p>Actions available to terms/plugins when doing propagation/model building,
including adding clauses, registering actions to do upon
backtracking, etc.</p></div></div><div class="spec val" id="val-field_t_is_deleted"><a href="#val-field_t_is_deleted" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>field_t_is_deleted : <a href="Term_fields/index.html#type-field">Term_fields.field</a></code></div><div class="doc"><p>term deleted during GC?</p></div></div><div class="spec val" id="val-field_t_is_added"><a href="#val-field_t_is_added" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>field_t_is_added : <a href="Term_fields/index.html#type-field">Term_fields.field</a></code></div><div class="doc"><p>term deleted during GC?</p><p>term added to core solver?</p></div></div><div class="spec val" id="val-field_t_mark_pos"><a href="#val-field_t_mark_pos" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>field_t_mark_pos : <a href="Term_fields/index.html#type-field">Term_fields.field</a></code></div><div class="doc"><p>term added to core solver?</p><p>positive atom marked?</p></div></div><div class="spec val" id="val-field_t_mark_neg"><a href="#val-field_t_mark_neg" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>field_t_mark_neg : <a href="Term_fields/index.html#type-field">Term_fields.field</a></code></div><div class="doc"><p>positive atom marked?</p><p>negative atom marked?</p></div></div><div class="spec val" id="val-field_t_seen"><a href="#val-field_t_seen" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>field_t_seen : <a href="Term_fields/index.html#type-field">Term_fields.field</a></code></div><div class="doc"><p>negative atom marked?</p><p>term seen during some traversal?</p></div></div><div class="spec val" id="val-field_t_negated"><a href="#val-field_t_negated" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>field_t_negated : <a href="Term_fields/index.html#type-field">Term_fields.field</a></code></div><div class="doc"><p>term seen during some traversal?</p><p>negated term?</p></div></div><div class="spec val" id="val-field_t_gc_marked"><a href="#val-field_t_gc_marked" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>field_t_gc_marked : <a href="Term_fields/index.html#type-field">Term_fields.field</a></code></div><div class="doc"><p>negated term?</p><p>marked for GC?</p></div></div><div class="spec val" id="val-field_c_attached"><a href="#val-field_c_attached" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>field_c_attached : <a href="Clause_fields/index.html#type-field">Clause_fields.field</a></code></div><div class="doc"><p>clause added to state?</p></div></div><div class="spec val" id="val-field_c_visited"><a href="#val-field_c_visited" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>field_c_visited : <a href="Clause_fields/index.html#type-field">Clause_fields.field</a></code></div><div class="doc"><p>clause added to state?</p><p>visited during some traversal?</p></div></div><div class="spec val" id="val-field_c_deleted"><a href="#val-field_c_deleted" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>field_c_deleted : <a href="Clause_fields/index.html#type-field">Clause_fields.field</a></code></div><div class="doc"><p>visited during some traversal?</p><p>deleted during GC</p></div></div><div class="spec val" id="val-field_c_gc_marked"><a href="#val-field_c_gc_marked" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>field_c_gc_marked : <a href="Clause_fields/index.html#type-field">Clause_fields.field</a></code></div><div class="doc"><p>deleted during GC</p><p>clause is alive for GC</p></div></div><div class="spec extension"><div class="def extension"><code><span class="keyword">type </span><a href="index.html#type-term_view">term_view</a><span class="keyword"> += </span></code><code><span class="extension">Dummy</span></code></div><div class="doc"></div></div><div class="spec val" id="val-tct_default"><a href="#val-tct_default" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>tct_default : <a href="index.html#type-tc_term">tc_term</a></code></div><div class="doc"></div></div><div class="spec val" id="val-dummy_tct"><a href="#val-dummy_tct" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>dummy_tct : <a href="index.html#type-tc_term">tc_term</a></code></div><div class="doc"></div></div><div class="spec val" id="val-dummy_term"><a href="#val-dummy_term" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>dummy_term : <a href="index.html#type-term">term</a></code></div><div class="doc"></div></div><div class="spec val" id="val-dummy_clause"><a href="#val-dummy_clause" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>dummy_clause : <a href="index.html#type-clause">clause</a></code></div><div class="doc"></div></div><div class="spec val" id="val-dummy_atom"><a href="#val-dummy_atom" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>dummy_atom : <a href="index.html#type-atom">atom</a></code></div><div class="doc"></div></div><div class="spec type" id="type-bool_term"><a href="#type-bool_term" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>bool_term</code><code><span class="keyword"> = </span><a href="index.html#type-term">term</a></code><code></code></div><div class="doc"><p>Alias for boolean terms</p></div></div><h3>Decisions and propagations</h3><div class="spec type" id="type-trail"><a href="#type-trail" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>trail</code><code><span class="keyword"> = </span><a href="index.html#type-term">term</a> <a href="../Vec/index.html#type-t">Mc2_core__.Vec.t</a></code><code></code></div><div class="doc"><p>A trail is a vector of assignments. An assignment is simply
a term whose value is decided.</p></div></div><div class="spec type" id="type-assignment_view"><a href="#type-assignment_view" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>assignment_view</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-assignment_view.A_bool" class="anchored"><td class="def constructor"><a href="#type-assignment_view.A_bool" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">A_bool</span><span class="keyword"> of </span><a href="index.html#type-term">term</a><span class="keyword"> * </span>bool</code></td></tr><tr id="type-assignment_view.A_semantic" class="anchored"><td class="def constructor"><a href="#type-assignment_view.A_semantic" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">A_semantic</span><span class="keyword"> of </span><a href="index.html#type-term">term</a><span class="keyword"> * </span><a href="index.html#type-value">value</a></code></td></tr></table><code></code></div><div class="doc"></div></div><div class="spec type" id="type-or_conflict"><a href="#type-or_conflict" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>'a or_conflict</code><code><span class="keyword"> = </span>(<span class="type-var">'a</span>, <a href="index.html#type-clause">clause</a>) CCResult.t</code><code></code></div><div class="doc"><p>Either an <code class="code">'a</code>, or a conflict clause</p></div></div></body></html>